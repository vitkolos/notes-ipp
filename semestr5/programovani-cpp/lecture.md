# Programming in C++

- header files in C++
	- the whole class has to be in the header file (including implementation of the member functions, even private members)
- it is not a good idea to try to modify the value of a function parameter
- when using `const` and pointers together, it might get complicated
	- the behavior will differ based on the `const` keyword position
- function declaration vs. definition
	- declaration – in the header (hpp) file
		- does not have to contain names of the parameters
		- can contain default values of the parameters
	- definition – in the source (cpp) file
- `inline` keyword
- if you insert something in a container, it is copied
- `const` keyword
- `auto&&` → compiler will determine the best way to access the item (might even use const)
- `std::string`
	- mutable
	- assignment copies the characters
	- small strings may be located inside the std::string object (in some implementations)
	- larger strings are stored in a dynamically allocated block owned by the std::string object
		- if the appended characters can fit inside the block, they are just appended
		- otherwise, a larger block is allocated and all the characters are copied there
- how to (not) share links
	- value … `T`
		- default value defined by default constructor
		- we can use `x.member`
	- raw (C) pointers … `T *`
		- undefined by default (if not global)
			- it is good practice to set them as null pointer
		- the instance needs to be deleted (exactly once)
		- star needs to be repeated when creating multiple pointer variables
		- we can use `(*x).member` or `x->member`
	- smart pointers … `std::shared_ptr<T>`
		- initialized as null pointer
		- we can use `x->member`
	- references … `T &`
		- must be initialized
		- cannot be redirected
		- we can use `x.member`
		- reference does not own the object, it has to be owned by someone else
		- assignment replaces the value of the referenced object
- references
	- `T &` used as an output parameter
	- `const T &` used as an input parameter
	- `T &&` used to steal from them
		- two types of r-values
			- prvalue (pure r-value)
			- xvalue (result of std::move or other function/cast returning T&&)
- resolution of the overloaded function depends on the number and types of the arguments
	- or, for member functions, it depends on the type of the object (whether it's modifiable or not)
- rule of five
- virtual destructor for abstract classes
- conventions for the use of references and pointers
